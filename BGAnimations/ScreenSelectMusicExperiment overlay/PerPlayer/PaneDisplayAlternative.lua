local player = ...
local pn = ToEnumShortString(player)
local rv
local zoom_factor = WideScale(0.8, 0.9)

local labelX_col1 = WideScale(-70, -90)
local dataX_col1 = WideScale(-75, -96)

local labelX_col2 = WideScale(10, 20)
local dataX_col2 = WideScale(5, 15)

local highscoreX = WideScale(56, 80)
local highscorenameX = WideScale(61, 97)

local FormatDate = function(scoredate)
	if scoredate == "" then
		return ""
	else
		local numbers = {}
		for number in string.gmatch(scoredate, "%d+") do
			numbers[#numbers + 1] = number
		end
		if #numbers ~= 3 then return scoredate end --if we don't have three numbers it's a malformed date so send it back
		return numbers[2] .. "-" .. numbers[3] .. "-" .. numbers[1]
	end
end

local GetNameAndScoreAndDate = function(profile)
	local song = (GAMESTATE:IsCourseMode() and GAMESTATE:GetCurrentCourse()) or GAMESTATE:GetCurrentSong()
	local steps = (GAMESTATE:IsCourseMode() and GAMESTATE:GetCurrentTrail(player)) or GAMESTATE:GetCurrentSteps(player)
	local score = ""
	local name = ""
	local scoredate = ""
	if profile and song and steps then
		local scorelist = profile:GetHighScoreList(song, steps)
		local scores = scorelist:GetHighScores()
		local topscore = scores[1]

		if topscore then
			score = string.format("%.2f%%", topscore:GetPercentDP() * 100.0)
			name = topscore:GetName()
			scoredate = topscore:GetDate()
		else
			score = string.format("%.2f%%", 0)
			name = "????"
			scoredate = ""
		end
	end

	return score, name, scoredate
end

local af =
	Def.ActorFrame {
	InitCommand = function(self)
		self:visible(GAMESTATE:IsHumanPlayer(player))
		--TODO for now if there's only one player their pane display is on the left. We only put things on the right if two people are joined
	end,
	PlayerJoinedMessageCommand = function(self)
		self:visible(true)
	end,
	-- These playcommand("Set") need to apply to the ENTIRE panedisplay
	-- (all its children) so declare each here
	OnCommand = function(self) self:queuecommand("Set") end,
	CurrentCourseChangedMessageCommand = function(self) self:queuecommand("Set") end,
	StepsHaveChangedMessageCommand = function(self) self:queuecommand("Set") end,
	SetCommand = function(self)
		local player_score, player_date, first_pass, last_played, times_played
		if GAMESTATE:GetCurrentSong() then --if there's no song there won't be a hash
			local hash = GetCurrentHash(player)
			if hash and SL[pn].Scores[GetCurrentHash(player)] then
				if GetScores(player, hash) then
					player_score = FormatPercentScore(GetScores(player, hash)[1].score)
					player_date = FormatDate(Split(GetScores(player, hash)[1].dateTime)[1])
				else
					player_score = string.format("%.2f%%", 0)
					player_date = "Never"
				end
				first_pass = FormatDate(Split(SL[pn].Scores[GetCurrentHash(player)].FirstPass)[1])
				last_played = FormatDate(Split(SL[pn].Scores[GetCurrentHash(player)].LastPlayed)[1])
				times_played = SL[pn].Scores[GetCurrentHash(player)].NumTimesPlayed
			else
				player_score, _ , player_date = GetNameAndScoreAndDate(PROFILEMAN:GetProfile(player))
				--if there's a player_score/date then the song is in stats.xml but we can't make a hash for whatever reason
				if #player_date > 0 then
					player_date = FormatDate(Split(player_date)[1])
					--TODO last_played and times_played are both in stats but i don't feel like parsing it just for that.
					first_pass = "Unknown"
					last_played = "Unknown"
					times_played = "Unknown"
				--otherwise it's a song we haven't played yet so
				else
					first_pass = "Never"
					player_date = "Never Played"
					last_played = "Never"
					times_played = "0"
				end
			end
			self:GetChild("LastPlayedDate"):settext("Last Played: "..last_played)
			self:GetChild("PlayerHighScore"):settext("High Score: "..player_score)
			self:GetChild("PlayerHighScoreDate"):settext("Date: "..player_date)
			self:GetChild("FirstPass"):settext("First Pass: "..first_pass)
			self:GetChild("TimesPlayed"):settext("Times Played: "..times_played)

			local SongOrCourse = (GAMESTATE:IsCourseMode() and GAMESTATE:GetCurrentCourse()) or GAMESTATE:GetCurrentSong()
			if not SongOrCourse then
				self:settext("?")
				return
			end

			local steps = (GAMESTATE:IsCourseMode() and GAMESTATE:GetCurrentTrail(player)) or GAMESTATE:GetCurrentSteps(player)
			if steps then
				rv = steps:GetRadarValues(player)
				local val = rv:GetValue("RadarCategory_TapsAndHolds")

				-- the engine will return -1 as the value for autogenerated content; show a question mark instead if so
				self:GetChild("Steps"):settext("Steps: "..(val >= 0 and val or "?"))
			else
				self:GetChild("Steps"):settext("Steps: ")
			end
		end
	end
}

-- colored background for chart statistics
af[#af + 1] =
	Def.Quad {
	Name = "BackgroundQuad",
	InitCommand = function(self)
		self:zoomto(_screen.w / 2 - 10, _screen.h / 8):y(_screen.h / 2 - 67)
	end,
	SetCommand = function(self)
		if GAMESTATE:IsHumanPlayer(player) then
			local StepsOrTrail = GAMESTATE:IsCourseMode() and GAMESTATE:GetCurrentTrail(player) or GAMESTATE:GetCurrentSteps(player)

			if StepsOrTrail then
				local difficulty = StepsOrTrail:GetDifficulty()
				self:diffuse(DifficultyColor(difficulty))
			else
				self:diffuse(PlayerColor(player))
			end
		end
	end
}

-- chart difficulty meter
af[#af + 1] =
	LoadFont("_wendy small") ..
	{
		Name = "DifficultyMeter",
		InitCommand = function(self)
			self:horizalign(right):diffuse(Color.Black)
				:xy(_screen.w / 4 - 10, _screen.h / 2 - 65):queuecommand("Set")
		end,
		SetCommand = function(self)
			local SongOrCourse = (GAMESTATE:IsCourseMode() and GAMESTATE:GetCurrentCourse()) or GAMESTATE:GetCurrentSong()
			if not SongOrCourse then
				self:settext("")
				return
			end

			local StepsOrTrail = GAMESTATE:IsCourseMode() and GAMESTATE:GetCurrentTrail(player) or GAMESTATE:GetCurrentSteps(player)
			local meter = StepsOrTrail and StepsOrTrail:GetMeter() or "?"
			self:settext(meter)
		end
	}

-- steps label
af[#af +1] =
	LoadFont("Common Normal") ..
		{
			Name = "Steps",
			InitCommand = function(self)
				self:zoom(zoom_factor):xy(-_screen.w / 10 + dataX_col1, 156):diffuse(Color.Black):halign(0)
			end
		}

--PLAYER PROFILE high score
af[#af + 1] =
	LoadFont("Common Normal") ..
	{
		Name = "PlayerHighScore",
		InitCommand = function(self)
			self:xy(-_screen.w / 10 + highscoreX, 156):zoom(zoom_factor):diffuse(Color.Black):halign(0)
		end
	}

--Last Played
af[#af + 1] =
	LoadFont("Common Normal") ..
	{
		Name = "LastPlayedDate",
		InitCommand = function(self)
			self:xy(-_screen.w / 10 + dataX_col1, 176):zoom(zoom_factor):diffuse(Color.Black):halign(0)
		end
	}

--Times Played
af[#af + 1] =
	LoadFont("Common Normal") ..
	{
		Name = "TimesPlayed",
		InitCommand = function(self)
			self:xy(-_screen.w / 10 + dataX_col1, 196):zoom(zoom_factor):diffuse(Color.Black):halign(0)
		end
	}
--PlayerHighScoreDate
af[#af + 1] =
	LoadFont("Common Normal") ..
	{
		Name = "PlayerHighScoreDate",
		InitCommand = function(self)
			self:xy(-_screen.w / 10 + highscoreX, 176):zoom(zoom_factor):diffuse(Color.Black):halign(0)
		end
	}

--First Passed Date
af[#af + 1] =
	LoadFont("Common Normal") ..
	{
		Name = "FirstPass",
		InitCommand = function(self)
			self:xy(-_screen.w / 10 + highscoreX, 193):zoom(zoom_factor):diffuse(Color.Black):halign(0)
		end
	}
return af
